/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */
/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */
// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: 34tvEQuyqfK98iGCjMbawB
// Component: jaOmCC9X_Oxf
import * as React from "react";
import { useRouter } from "next/router";
import {
  Stack as Stack__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts
} from "@plasmicapp/react-web";
import { useDataEnv } from "@plasmicapp/react-web/lib/host";
import "@plasmicapp/react-web/lib/plasmic.css";
import plasmic_antd_5_hostless_css from "../antd_5_hostless/plasmic.module.css"; // plasmic-import: ohDidvG9XsCeFumugENU3J/projectcss
import plasmic_plasmic_rich_components_css from "../plasmic_rich_components/plasmic.module.css"; // plasmic-import: jkU633o1Cz7HrJdwdxhVHk/projectcss
import projectcss from "./plasmic.module.css"; // plasmic-import: 34tvEQuyqfK98iGCjMbawB/projectcss
import sty from "./PlasmicComponentSectionTitle.module.css"; // plasmic-import: jaOmCC9X_Oxf/css

createPlasmicElementProxy;

export const PlasmicComponentSectionTitle__VariantProps = new Array();

export const PlasmicComponentSectionTitle__ArgProps = new Array(
  "title",
  "descriptionSection"
);

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicComponentSectionTitle__RenderFunc(props) {
  const { variants, overrides, forNode } = props;
  const args = React.useMemo(
    () =>
      Object.assign(
        {
          title: "Title Section",
          descriptionSection:
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur."
        },
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );
  const $props = {
    ...args,
    ...variants
  };
  const __nextRouter = useNextRouter();
  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;
  return (
    <div
      data-plasmic-name={"root"}
      data-plasmic-override={overrides.root}
      data-plasmic-root={true}
      data-plasmic-for-node={forNode}
      className={classNames(
        projectcss.all,
        projectcss.root_reset,
        projectcss.plasmic_default_styles,
        projectcss.plasmic_mixins,
        projectcss.plasmic_tokens,
        plasmic_antd_5_hostless_css.plasmic_tokens,
        plasmic_plasmic_rich_components_css.plasmic_tokens,
        sty.root
      )}
    >
      <Stack__
        as={"div"}
        data-plasmic-name={"frame2"}
        data-plasmic-override={overrides.frame2}
        hasGap={true}
        className={classNames(projectcss.all, sty.frame2)}
      >
        <div
          className={classNames(
            projectcss.all,
            projectcss.__wab_text,
            sty.text__fhuE8
          )}
        >
          <React.Fragment>
            {(() => {
              try {
                return $props.title;
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return "CME & MOC";
                }
                throw e;
              }
            })()}
          </React.Fragment>
        </div>
        <div
          className={classNames(
            projectcss.all,
            projectcss.__wab_text,
            sty.text__fT4O3
          )}
        >
          <React.Fragment>
            {(() => {
              try {
                return $props.descriptionSection;
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return "Continuing medical education (CME)\u00a0and Maintenance of Certification (MOC) are important to help advance the science and practice of hand and upper extremity surgery and reconstructive microsurgery.";
                }
                throw e;
              }
            })()}
          </React.Fragment>
        </div>
      </Stack__>
    </div>
  );
}

const PlasmicDescendants = {
  root: ["root", "frame2"],
  frame2: ["frame2"]
};

function makeNodeComponent(nodeName) {
  const func = function (props) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicComponentSectionTitle__ArgProps,
          internalVariantPropNames: PlasmicComponentSectionTitle__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicComponentSectionTitle__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicComponentSectionTitle";
  } else {
    func.displayName = `PlasmicComponentSectionTitle.${nodeName}`;
  }
  return func;
}

export const PlasmicComponentSectionTitle = Object.assign(
  // Top-level PlasmicComponentSectionTitle renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    frame2: makeNodeComponent("frame2"),
    // Metadata about props expected for PlasmicComponentSectionTitle
    internalVariantProps: PlasmicComponentSectionTitle__VariantProps,
    internalArgProps: PlasmicComponentSectionTitle__ArgProps
  }
);

export default PlasmicComponentSectionTitle;
/* prettier-ignore-end */
